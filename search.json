[{"title":"设计模式六大原则","url":"/2019/02/15/设计模式六大原则/","content":"\n\n## 设计模式六大原则\n### （1）：单一职责原则\n定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。  \n\n问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。\n\n解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。\n\n### （2）：里氏替换原则\n定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。\n\n定义2：所有引用基类的地方必须能透明地使用其子类的对象。\n\n里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：\n1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。\n2.   子类中可以增加自己特有的方法。\n3.   当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。\n4.   当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。\n\n### （3）：依赖倒置原则\n定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。\n\n问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。\n\n解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。\n\n传递依赖关系有三种方式，接口传递，构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。\n\n在实际编程中，我们一般需要做到如下3点：\n1.   低层模块尽量都要有抽象类或接口，或者两者都有。\n2.  变量的声明类型尽量是抽象类或接口。\n3.  使用继承时遵循里氏替换原则。\n\n### （4）：接口隔离原则\n定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。  \n问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。\n\n解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。\n采用接口隔离原则对接口进行约束时，要注意以下几点：\n\n-   接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。\n-   为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。\n-   提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。\n\n### （5）：迪米特法则\n定义：一个对象应该对其他对象保持最少的了解。\n\n问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。\n\n解决方案：尽量降低类与类之间的耦合。\n### （6）：开闭原则\n定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。\n\n解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。","tags":["design patterns"]},{"title":"maven Invalid bound statement","url":"/2018/12/10/maven问题/","content":"## 问题\n昨天在使用maven构建mybatis+spring boot项目时:出现了\n> org.apache.ibatis.binding.BindingException: Invalid bound statement (not found) exception\n\n## 网上总结的一般原因  \nMapper interface和xml文件的定义对应不上，需要检查包名，namespace，函数名称等能否对应上。  \n按以下步骤一一执行：  \n1、检查xml文件所在的package名称是否和interface对应的package名称一一对应  \n2、检查xml文件的namespace是否和xml文件的package名称一一对应  \n3、检查函数名称能否对应上  \n4、去掉xml文件中的中文注释  \n5、随意在xml文件中加一个空格或者空行然后保存\n但是在我检查完上述步骤后，并没有发现所谓错误。于是我查看了编译后的target文件夹发现，在文件夹中并没有使用的mapper文件，于是我在网上查看了一下资料发现maven项目默认不会编译Java文件夹里的代码，而是集中编译resources文件夹。\n## 解决方案\n\n### 解决方法一\n使用项目路径下resources文件夹,把所有的配置文件都放到resources中管理.\n![](http://xiaosmie-blog-img.oss-cn-beijing.aliyuncs.com/18-12-10/31244278.jpg)\n### 解决方法二\n在pom文件中添加指定资源目录\n```\n  <build>\n        ...\n        <resources>\n            ...\n            <!--指定xml文件位置-->\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n```\n","tags":["maven"]},{"title":"Java二维数组引用","url":"/2018/08/24/Java二维数组引用/","content":"\n## 问题\n\n&emsp;&emsp;今天在使用eclipse编写Java代码时出现了很有意思的问题，在使用数组的clone方法对二维数组进行克隆后修改克隆后的数组，原数组也会发生改变，类似引用类型的引用。\n## Photo\n\n![测试代码](https://xiaosmie-blog-img.oss-cn-beijing.aliyuncs.com/18-8-24/81188676.jpg)\n\n## 原因\n\n在网上找到的解释:clone方法再拷贝二维数组是其实是把二维数组中的一维数组引用给了新的数组。\n\n> Java跟C/C++一样，没有二维数组，二维数组是一维数组的一维数组，用int[][] c =\n> a.clone()，实际上是把a[0]，a[1]，a[2]给clone了一份给c，也就是把每一行的一维数组的引用拷贝了一份给c，但是这些引用所指向的内存空间还是原来那一块，并不是彻底的深拷贝，在后续对c的操作中还是会同时作用在a上。因此应该对每一行的一维数组分别进行clone，才是彻底的深拷贝。\n![example picture](https://img-blog.csdn.net/20170208110119634)\n","tags":["Java"]},{"title":"vue后续","url":"/2018/08/07/vue后续/","content":"# Vue路由\nrouter-link 相当于就是超链。to 相当于就是 href\n`<router-link to=\"/user\">用户管理</router-link>`\n# Vue Ajax\n1. Jquery ajax\n2. fetch.js\n3. axios.js\n","tags":["js"]},{"title":"vue初步学习","url":"/2018/08/06/vue初步学习/","content":"# 什么是Vue\n>考虑这个需求： 我们要把一个 json对象的数据，显示到一个元素上去。\n>如果不使用 Vue, 那么就会用到 JS 或者 JQuery，通过操作 HTML DOM 的方式，把数据显示上去。\n>如果使用Vue, 那么仅仅需要提供数据，以及数据要绑定到的元素的id,就行了,不需要显式地操作HTML DOM。\n# Vue的语法\n1. 条件语句\n\t+ v-if\n\t+ v-else\n\t+ v-else-if\n2. 循环语句\nv-for循环语句\n3. 属性绑定\nv-bind\n4. 双向绑定\nv-model\n5. 监听属性\nwatch\n# 过滤器\n定义全局过滤器，后添加过滤器名称\n# Vue component\nvue组件定义全局组件\n","tags":["js"]}]